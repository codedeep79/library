export function SVD(r,t,o,e,n){if(t=void 0===t||t,o=void 0===o||o,e=e||Math.pow(2,-52),n=n||1e-64/e,!r)throw new TypeError("Matrix a is not defined");const f=r[0].length,i=r.length;if(i<f)throw new TypeError("Invalid matrix: m < n");let s,a,l,h,u,c,p,g,M,m,w,v,x;g=0,w=0;const y=[],d=[],q=[],b="f"===t?i:f;for(s=0;s<i;s++)d[s]=new Array(b).fill(0);for(s=0;s<f;s++)q[s]=new Array(f).fill(0);const E=new Array(f).fill(0);for(s=0;s<i;s++)for(a=0;a<f;a++)d[s][a]=r[s][a];for(s=0;s<f;s++){for(y[s]=g,m=0,h=s+1,a=s;a<i;a++)m+=Math.pow(d[a][s],2);if(m<n)g=0;else for(M=(p=d[s][s])*(g=p<0?Math.sqrt(m):-Math.sqrt(m))-m,d[s][s]=p-g,a=h;a<f;a++){for(m=0,l=s;l<i;l++)m+=d[l][s]*d[l][a];for(p=m/M,l=s;l<i;l++)d[l][a]=d[l][a]+p*d[l][s]}for(E[s]=g,m=0,a=h;a<f;a++)m+=Math.pow(d[s][a],2);if(m<n)g=0;else{for(M=(p=d[s][s+1])*(g=p<0?Math.sqrt(m):-Math.sqrt(m))-m,d[s][s+1]=p-g,a=h;a<f;a++)y[a]=d[s][a]/M;for(a=h;a<i;a++){for(m=0,l=h;l<f;l++)m+=d[a][l]*d[s][l];for(l=h;l<f;l++)d[a][l]=d[a][l]+m*y[l]}}(v=Math.abs(E[s])+Math.abs(y[s]))>w&&(w=v)}if(o)for(s=f-1;s>=0;s--){if(0!==g){for(M=d[s][s+1]*g,a=h;a<f;a++)q[a][s]=d[s][a]/M;for(a=h;a<f;a++){for(m=0,l=h;l<f;l++)m+=d[s][l]*q[l][a];for(l=h;l<f;l++)q[l][a]=q[l][a]+m*q[l][s]}}for(a=h;a<f;a++)q[s][a]=0,q[a][s]=0;q[s][s]=1,g=y[s],h=s}if(t){if("f"===t)for(s=f;s<i;s++){for(a=f;a<i;a++)d[s][a]=0;d[s][s]=1}for(s=f-1;s>=0;s--){for(h=s+1,g=E[s],a=h;a<b;a++)d[s][a]=0;if(0!==g){for(M=d[s][s]*g,a=h;a<b;a++){for(m=0,l=h;l<i;l++)m+=d[l][s]*d[l][a];for(p=m/M,l=s;l<i;l++)d[l][a]=d[l][a]+p*d[l][s]}for(a=s;a<i;a++)d[a][s]=d[a][s]/g}else for(a=s;a<i;a++)d[a][s]=0;d[s][s]=d[s][s]+1}}let A;for(e*=w,l=f-1;l>=0;l--)for(let r=0;r<50;r++){for(A=!1,h=l;h>=0;h--){if(Math.abs(y[h])<=e){A=!0;break}if(Math.abs(E[h-1])<=e)break}if(!A)for(c=0,m=1,u=h-1,s=h;s<l+1&&(p=m*y[s],y[s]=c*y[s],!(Math.abs(p)<=e));s++)if(g=E[s],E[s]=Math.sqrt(p*p+g*g),c=g/(M=E[s]),m=-p/M,t)for(a=0;a<i;a++)v=d[a][u],x=d[a][s],d[a][u]=v*c+x*m,d[a][s]=-v*m+x*c;if(x=E[l],h===l){if(x<0&&(E[l]=-x,o))for(a=0;a<f;a++)q[a][l]=-q[a][l];break}for(w=E[h],p=(((v=E[l-1])-x)*(v+x)+((g=y[l-1])-(M=y[l]))*(g+M))/(2*M*v),g=Math.sqrt(p*p+1),p=((w-x)*(w+x)+M*(v/(p<0?p-g:p+g)-M))/w,c=1,m=1,s=h+1;s<l+1;s++){if(g=y[s],v=E[s],M=m*g,g*=c,x=Math.sqrt(p*p+M*M),y[s-1]=x,p=w*(c=p/x)+g*(m=M/x),g=-w*m+g*c,M=v*m,v*=c,o)for(a=0;a<f;a++)w=q[a][s-1],x=q[a][s],q[a][s-1]=w*c+x*m,q[a][s]=-w*m+x*c;if(x=Math.sqrt(p*p+M*M),E[s-1]=x,p=(c=p/x)*g+(m=M/x)*v,w=-m*g+c*v,t)for(a=0;a<i;a++)v=d[a][s-1],x=d[a][s],d[a][s-1]=v*c+x*m,d[a][s]=-v*m+x*c}y[h]=0,y[l]=p,E[l]=w}for(s=0;s<f;s++)E[s]<e&&(E[s]=0);return{u:d,q:E,v:q}}export function MatrixMultiply(r,t){const o=[r,t],e=o.map(r=>r[0].length);if(!o.every((r,t)=>r.every(r=>r.length===e[t])))throw new Error("All rows in a matrix must have the same number of columns");if(e[0]!==t.length)throw new Error("The number of columns in the 1st matrix must be equal to the number of rows in the 2nd matrix");return r.map(r=>t[0].map((o,e)=>r.reduce((r,o,n)=>r+o*t[n][e],0)))}export function Transform(r,t){return MatrixMultiply(t,MatrixTranspose(r))}export function MatrixTranspose(r){return r[0].map((t,o)=>r.map(r=>r[o]))}export function MatrixInverse(r){const t=r.length,o=[];let e,n,f,i;for(n=0;n<t;n++)o[n]=[];for(n=0;n<t;n++)for(f=0;f<t;f++)o[n][f]=0,n==f&&(o[n][f]=1);for(i=0;i<t;i++){for(e=r[i][i],f=0;f<t;f++)r[i][f]/=e,o[i][f]/=e;for(n=i+1;n<t;n++)for(e=r[n][i],f=0;f<t;f++)r[n][f]-=r[i][f]*e,o[n][f]-=o[i][f]*e}for(i=t-1;i>0;i--)for(n=i-1;n>=0;n--)for(e=r[n][i],f=0;f<t;f++)r[n][f]-=r[i][f]*e,o[n][f]-=o[i][f]*e;for(n=0;n<t;n++)for(f=0;f<t;f++)r[n][f]=o[n][f];return r}function _isSquare(r){const t=0===r.length?0:r[0].length;return r.length===t}function _toRightTriangular(r){if(0===r.length)return[];const t=r.map(r=>r.slice(0)),o=r.length,e=r[0].length;let n,f,i,s;for(f=0;f<o;f++){if(0===t[f][f])for(i=f+1;i<o;i++)if(0!==t[i][f]){for(n=[],s=0;s<e;s++)n.push(t[f][s]+t[i][s]);t[f]=n;break}if(0!==t[f][f])for(i=f+1;i<o;i++){const r=t[i][f]/t[f][f];for(n=[],s=0;s<e;s++)n.push(s<=f?0:t[i][s]-t[f][s]*r);t[i]=n}}return t}export function Determinant(r){if(0===r.length||!_isSquare(r))return null;const t=_toRightTriangular(r);let o=t[0][0];const e=t.length;for(let r=1;r<e;r++)o*=t[r][r];return o}export function VectorFitting(r){if(void 0===r||0===r.length)throw new Error("Empty vector list!");const t=r[0].length,o=r.length;if(t<1||o<1)throw new Error("Invalid vectors!");if(!r.every(r=>r.length===t))throw new Error("All vectors should have same length!");const e=[],n=new Array(t).fill(0);let f,i;for(f=0;f<o;f++)for(i=0;i<t;i++)n[i]+=r[f][i];for(i=0;i<t;i++)n[i]/=o;for(f=0;f<o;f++){const o=[];for(i=0;i<t;i++)o.push(r[f][i]-n[i]);e.push(o)}const{u:s,q:a,v:l}=SVD(e,!1),h=a.indexOf(Math.min(...a)),u=[];for(i=0;i<l.length;i++)u.push(l[i][h]);return{normal:u,center:n}}export function Procrustes(r,t,o=!0,e=!0,n=!1){if(void 0===r||void 0===t||0===r.length||0===t.length||r[0].length<1)throw new Error("Invalid target vectors or source vectors!");const f=r[0].length,i=r.length;if(f<1||i<1)throw new Error("Invalid vectors!");if(r.length!==t.length)throw new Error("Number of source vectors and target vectors must be the same!");if(!r.every(r=>r.length===f)||!t.every(r=>r.length===f))throw new Error("All vectors should have same length!");const s=new Array(f).fill(0),a=new Array(f).fill(0);let l,h,u=0,c=0;for(l=0;l<i;l++)for(h=0;h<f;h++)s[h]+=r[l][h],a[h]+=t[l][h];for(h=0;h<f;h++)s[h]/=i,a[h]/=i;const p=[],g=[];for(h=0;h<f;h++)g.push([]);for(l=0;l<i;l++){const o=[],n=[];for(h=0;h<f;h++){const e=r[l][h]-s[h],f=t[l][h]-a[h];o.push(e),n.push(f),g[h].push(f)}if(e){let r=0,t=0;for(h=0;h<f;h++)r+=o[h]**2,t+=n[h]**2;u+=Math.sqrt(r),c+=Math.sqrt(t)}p.push(o)}const M=MatrixMultiply(g,p),{u:m,q:w,v:v}=SVD(M),x=MatrixTranspose(v),y=MatrixMultiply(m,x);let d=y;if(!n&&Determinant(y)<0){const r=w.indexOf(Math.min(...w)),t=[];for(h=0;h<f;h++){const r=new Array(f).fill(0);r[h]=1,t.push(r)}t[r][r]*=-1,d=MatrixMultiply(m,MatrixMultiply(t,x))}if(e){const r=c/u;d=d.map(t=>t.map(t=>t*r))}const q=Transform(d,[s])[0],b=o?a:s,E=[];for(h=0;h<f;h++)E.push(b[h]-q[h]);return{transform:d,translation:E}}